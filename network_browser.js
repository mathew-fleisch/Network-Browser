div_id = "cytoscapeweb";
options = {
		swfPath: "/inc/swf/CytoscapeWeb",
		flashInstallerPathflashInstallerPath: "/inc/swf/playerProductInstall"
	};
window.vis = new org.cytoscapeweb.Visualization(div_id, options);
window.vis.ready(function() {
	window.vis.addListener("click", "nodes", function(event) {
		handle_click(event);
		event.preventDefault();
		return false;
	});
	window.vis.addListener("dblclick", "nodes", function(event) {
		handle_dblclick(event);
		event.preventDefault();
		return false;
	});
});
$(document).ready(function() { 
	//VARIABLES
	var prevSearch = "";
	usingFlash = true;
	database = "&database="+$("#networkSelect option:selected").val();
	crnt_db = "";
	last_db = crnt_db;
	db_track = -1;



	//Automatic Flash Detector
	if(!FlashDetect.installed) {
		//alert("Flash is not installed");	
		$('#flashSelector').css('display', 'none');
	}else{
		//alert("Flash is installed");
		
	}

	//This is to automatically load results for debugging
		var searchStr = "";
		$('li.hubNode').each(function(index) {
			var temp = $(this).attr('data-gene').toLowerCase();
			searchStr = searchStr+temp+",";
		});
		var search = searchStr.substr(0,(searchStr.length-1));
		$("#results").text("");
		$("#helpText").hide();
		$("#autoTerms").hide();
		$("#cytoscapeweb").text("");
		$("#chart").text("");
		searchNetwork(search);
	//Autoload code complete

	//User Flash/HTML5 toggle
	$("input[name='flashTrig']").change(function() {
		if($("input[name='flashTrig']:checked").val() == "true") {
			usingFlash = true;
			$("#cytoscapeweb").show();
			$("#chart").hide();
		}else{
			usingFlash = false;
			$("#cytoscapeweb").hide();
			$("#chart").show();
		}
	});

	$('#networkSelect').change(function() {
		database = "&database="+$("#networkSelect option:selected").val();
	});


	//User presses a key and the string is sent to the fn preSearch to auto complete like genes
	$('#optionsForm').submit(function() { pushToHub(); return false; });
	$('#userInput').keyup(function(event) {
		var trig = true;
		var code = (event.keyCode ? event.keyCode : event.which);
		switch(code)
		{
			case 13:
				trig = false;
				pushToHub();
				break;
			case 38:
				upAuto();
				break;
			case 40:
				downAuto();
				break;
			default:
				break;
		}
		if(trig)
		{
			var search = $("#userInput").val().toLowerCase();
			$("#results").text("");
			if(search.length > 1 && prevSearch != search)
			{
				$("#legendHolder").css("margin-top", "5px");
				$("#autoTerms").show();
				preSearch(search);
			}
			prevSearch = search;
		}
	});


	//Clear everything on the screen
	$('#clearNetwork').click(function() {
		$("#results").text("");
		$("#legendHolder").css("margin-top", "115px");
		$("#autoTerms").hide();
		$("#userInput").val("");
		$("#cytoscapeweb").text("");
		$("#chart").text("");
		$("#helpText").show();
		$(".hubNode").remove();
	});

	//Draw the network based on the list of hub genes generated by user
	$('#drawNetworkBtn').click(function() {
		var searchStr = "";
		$('li.hubNode').each(function(index) {
			var temp = $(this).attr('data-gene').toLowerCase();
			searchStr = searchStr+temp+",";
		});
		var search = searchStr.substr(0,(searchStr.length-1));
		$("#results").text("");
		$("#legendHolder").css("margin-top", "115px");
		$("#autoTerms").hide();
		$("#cytoscapeweb").text("");
		$("#cytoscapeweb").hide();
		$("#chart").text("");
		$("#helpText").hide();
		searchNetwork(search);
	});

	//Export Button
	$('#exportBtn').click(function(){
		//alert("exprt sub-network");
		var searchStr = "";
		$('li.hubNode').each(function(index) {
			var temp = $(this).attr('data-gene').toLowerCase();
			searchStr = searchStr+temp+",";
		});
		var search = searchStr.substr(0,(searchStr.length-1));
		exportNetwork(search);
	});

	//Hub Genes Mouse Events
	$('.hubNode').live("mouseover mouseout click", function(event) {
		if(event.type == "mouseover")	{
			$(this).css("font-weight", "bold");
		}
		if(event.type == "mouseout")	{
			$(this).css("font-weight", "normal");
		}
		if(event.type == "click")	{
			$(this).remove();
		}
	});

	//Auto Complete Mouse Events
	$('#userChoice').live("mouseover mouseout click", function(event) {
		if(event.type == "mouseover")	{
			$(this).css("font-weight", "bold");
		}
		if(event.type == "mouseout")	{
			$(this).css("font-weight", "normal");
		}
		if(event.type == "click")	{
			putSearchTerm($(this).attr('data-gene'));
		}
	});
});




/*------------ FUNCTIONS -------------*/

//Function:	expotNetwork()
//Input Var(s):	search(string) - comma sep string of gene names
//Description:	This function sends the "Hub Genes" defined by
//		the user though ajax to a php script that 
//		prints the output as a csv file.
function exportNetwork(search)
{
	database = "&database="+$("#networkSelect option:selected").val();
	exportWindow = window.open('/inc/exportNetwork.php?searchString='+search+database,'','width=200,height=100');
}
//End Function:	exportNetwork()


//Function:	putSearchTerm()
//Input Var(s):	search(string) - Gene name from mysql query
//Description:	Every time the user clicks on a gene from the auto-complete box
//		Push that gene to the "Hub Genes" list
//		It also does not allow a user to enter a gene twice
function putSearchTerm(search)
{
	var trig = 0;
	$('li.hubNode').each(function(index) {
		if($(this).attr('data-gene') == search)
		{
			trig = trig+1;
		}
	});
	if(!trig)
	{
		var parent = document.getElementById('hubNodes');
		var listitem = document.createElement('li');
		listitem.setAttribute('class','hubNode');
		listitem.setAttribute('data-gene',search);
		listitem.id = search;
		listitem.innerHTML = search;
		parent.appendChild(listitem);
	}
}
//End Function:	putSearchTerm()


//Function:	makeHubNode()
function makeHubNode(gene)
{
	var geneId = inNodes(gene);
	if(geneId)
	{
		//alert(gene+"("+geneId+")");
		var tempNode = window.vis.node(geneId);
		alert(dump(tempNode));
	}

	putSearchTerm(gene);
	ajax_hideTooltip();
}
//End Function: makeHubNode()


//Function:	inNodes()
//Input Var(s):	gene(string)
//Return:	gene-id or 0 on failure
//Description:	Since there are no hashes in javascript,
//		this function iterates through the current
//		nodes on the screen until the passed var
//		shows up, then it breaks out of the loop and
//		return's the node/gene's ID
function inNodes(gene)
{
	var nodes = window.vis.nodes();
	var ret = 0;
	for(i in nodes)
	{
		if(nodes[i].data.label == gene)
		{
			ret = nodes[i].data.id;
			continue;
		}
	}
	return ret;
}
//End Function:	inNodes();

//Function:	removeHubNode()
//Input Var(s):	gene(string)
//Description:	First I remove all nodes that are only connected to the
//		passed var(gene). 
//To Do:	Currently this function removes all nodes connected
//		to the passed var(gene), even if it is a hub gene or 
//		connected to a hub gene... I need to implement a filter 
//		that first checks to see if the node to be removed is 
//		a hub gene, and second checks if it is connected to a 
//		hub gene. If either of these conditions are true, 
//		do not delete the node.
//Might Be Easier to:
//		
function removeHubNode(gene)
{
	var edges		= window.vis.edges();
	var nodes		= window.vis.nodes();
	var hubNodes		= new Array();
	var dontDelete		= new Array();
	var toDelete		= new Array();
	var toDelete_genes	= new Array();
	var toDelete_ids	= new Array();
	var connectedToHub	= new Array();
	var edgeLabels		= new Array();
	var otherGenes		= new Array();
	var hubConnectedToHub	= false;
	var primaryId		= 0;
	var numEdges		= edges.length;
	var alertMsg		= "";

	
	$('li.hubNode').each(function(index) {
		var temp = $(this).attr('data-gene');
		if(temp != gene){
			hubNodes.push(temp);
		}
	});

	for(i in edges)
	{
		var tempEdge = edges[i];
		var percent = Math.round(((i+1)/numEdges)*100);
		var tempSource = tempEdge.data.source;
		var tempTarget = tempEdge.data.target;
		var tempId = tempEdge.data.id;
		var tempLabel = tempEdge.data.label.split("_");
		var gene1 = tempLabel[0];
		var gene2 = tempLabel[1];
		var otherGene = "";
		var deleteTrig = false;
		var re = new RegExp(gene+"_", "g");
		var er = new RegExp("_"+gene, "g");
		for(t in hubNodes)
		{
			var tempName_1 = gene+"_"+hubNodes[t];
			var tempName_2 = hubNodes[t]+"_"+gene;
			if(tempEdge.data.label == tempName_1 || tempEdge.data.label == tempName_2)
			{
				hubConnectedToHub = true;
			}
		}
		if(tempEdge.data.label.match(re) || tempEdge.data.label.match(er))
		{
			if(tempEdge.data.label.match(er)){
				otherGene = tempEdge.data.label.replace(er, "");
			}else{
				otherGene = tempEdge.data.label.replace(re, "");
			}

			if(!primaryId)
			{
				var targetGene = tempEdge;
				primaryId = tempSource;
			}

			if(tempTarget != primaryId)
			{
				toDelete.push(tempEdge);
				toDelete_genes.push(otherGene);
				toDelete_ids.push(tempTarget);
				//window.vis.removeNode(tempTarget);
			}
			if(tempSource != primaryId)
			{
				toDelete.push(tempEdge);
				toDelete_genes.push(otherGene);
				toDelete_ids.push(tempSource);
				//window.vis.removeNode(tempSource);
			}
			//window.vis.removeEdge(tempId);
		}
		if(toDelete_genes.length > 0)
		{
			for(x in toDelete_genes)
			{
				if(gene1 == toDelete_genes[x] || gene2 == toDelete_genes[x])
				{
					for(j in hubNodes)
					{
						if(hubNodes[j] == gene1 || hubNodes[j] == gene2)
						{
							dontDelete.push(toDelete_ids[x]);
							toDelete_genes.splice(x,1);
							toDelete_ids.splice(x,1);
							toDelete.splice(x,1);
						}
					}
				}
			}
		}
	}	
	for(x in toDelete_ids)
	{
		//alert(toDelete_genes[x]+" "+ toDelete_ids[x]);
		window.vis.removeNode(toDelete_ids[x]);
	}
	if(!hubConnectedToHub)
	{
		window.vis.removeNode(primaryId);
	}
	else
	{
		var temp = window.vis.node(primaryId);
		temp.data.searched = 0;
		window.vis.updateData([temp]);
	}
	var temp = document.getElementById(gene);
	$(temp).remove();
	window.vis.zoomToFit();
	ajax_hideTooltip();
}
//End Function:	removeHubNode()



//Function:	markGene()
//Input Var(s):	gene(string)
//Description:	This function changes the attribute value of "searched"
//		back and forth between 0 and 4 to essentially "mark" a gene
//		by changing the color of the node.
function markGene(gene)
{
	//alert(gene);
	var nodes = window.vis.nodes();
	for(i in nodes)
	{
		if(nodes[i].data.label == gene)
		{
			var temp = nodes[i];
			continue;
		}
	}

	switch(temp.data.searched) 
	{
		case 0:
			temp.data.searched = 4;
			break;
		case 4:
			temp.data.searched = 0;
			break;
		default:
			break;
	}

	window.vis.updateData([temp]);
	ajax_hideTooltip();
	return;
}
//End Function: markeGene()

//Function: 	preSearch()
//Input Var(s):	search(string) - User search of genes in database
//Description:	Every time the user adds a char to the search box,
//		this function does a wildcard mysql search to serve
//		as an "auto-complete" box. This ensures the output
//		must be available values, and prevents against mysql-
//		injection.
function preSearch(search)
{
	$("#autoTerms").text("");
	if(search)
	{
		$("#legendHolder").css("margin-top", "5px");
		$("#autoTerms").show();
	}
	else
	{
		$("#legendHolder").css("margin-top", "115px");
		$("#autoTerms").hide();
	}
	$.ajax({
		type: "POST", 
		url: "/inc/preSearch.php",
		data: "searchString="+search+database, 
		success: function(html){
			$('#autoTerms').append(html);
		}
	});
}
//End Function:	preSearch()


//Function:	searchNetwork()
//Input Var(s):	search(string) - Comma separated string of genes
//Description:	This function takes the "hub genes" defined by the user
//		and sends them through ajax to one of two external
//		search scripts; one for flash, and one for HTML5.
//		The scripts will each return a slightly different
//		json variable which then populates the nodes/edges
//		of a graph. If the user does not have flash or decides
//		not to use flash, the function displays an HTML5 graph;
//		otherwise it defaults to the flash player because it has
//		more functionality and can handle larger datasets.
function searchNetwork(search)
{
	//alert(database);
	$('#cytoscapeweb').hide();
	$('#chart').hide();
	$('#loading').show();
	if(usingFlash)
	{
		$.ajax({
			type: "POST", 
			url: "/inc/searchCW.php",
			data: "searchString="+search+database, 
			success: function(html){
				$('#results').append(html);

				//vis = new org.cytoscapeweb.Visualization(div_id, options);
				window.vis.draw({
					network: json_data,
					layout: {
						name: 'ForceDirected',
						options: {
							minDistance: 15,
						}
					},
					visualStyle: {
						nodes: {
							labelFontSize: 12,
							shape: "ellipse",
							size: 50,
							color: {
								discreteMapper: {
									attrName: "searched",
									entries: [
									{ attrValue: 0, value: "#eeeeee" },
									{ attrValue: 1, value: "#00ff00" },
									{ attrValue: 2, value: "#e10000" },
									{ attrValue: 3, value: "#ffff66" },
									{ attrValue: 4, value: "#bbbbbb" } ]
								}
							}
						},
						edges: {
							color: {
								discreteMapper: {
									attrName: "database",
									entries: [
									{ attrValue: "aa_hprd", value: "#ff3300" },
									{ attrValue: "aa_hprd_copy", value: "#ffaa00" },
									{ attrValue: "aa_option1", value: "#44aa00" },
									{ attrValue: "aa_option2", value: "#444444" } ]
								}
							}
						}
					}
				});
				$('#loading').hide();
				$('#cytoscapeweb').show();
			}
		});
	}else{
		//alert("HTML5");
		var w = 800,
		    h = 500,
		    trig = 0,
		    fill = d3.scale.category20();
		
		
		
		var vis = d3.select("#chart")
		  .append("svg:svg")
		    .attr("width", w)
		    .attr("height", h);
		
		d3.json("/inc/searchD3.php?searchString="+search+database, function(json) {
		  var force = d3.layout.force()
		      .charge(-120)
		      .linkDistance(30)
		      .nodes(json.nodes)
		      .links(json.links)
		      .size([w, h])
		      .start();
		
		  var link = window.vis.selectAll("line.link")
		      .data(json.links)
		    .enter().append("svg:line")
		      .attr("class", "link")
		      .style("stroke-width", function(d) { return Math.sqrt(4); })
		      .attr("x1", function(d) { return d.source.x; })
		      .attr("y1", function(d) { return d.source.y; })
		      .attr("x2", function(d) { return d.target.x; })
		      .attr("y2", function(d) { return d.target.y; });
		
		  var node = window.vis.selectAll("circle.node")
		      .data(json.nodes)
		    .enter().append("svg:circle")
		      .attr("class", "node")
		      .attr("cx", function(d) { return d.x; })
		      .attr("cy", function(d) { return d.y; })
		      .attr("r", 5).on("mousedown", function() { clickNode(this.__data__); })
		      .style("fill", function(d) { return fill(d.group); })
		      .call(force.drag);
		
		  node.append("svg:title")
		      .text(function(d) { return d.name; });
		
		  window.vis.style("opacity", 1e-6)
		    .transition()
		      .duration(1000)
		      .style("opacity", 1);
		
		
		
		  force.on("tick", function() {
		    link.attr("x1", function(d) { return d.source.x; })
		        .attr("y1", function(d) { return d.source.y; })
		        .attr("x2", function(d) { return d.target.x; })
		        .attr("y2", function(d) { return d.target.y; });
		
		    node.attr("cx", function(d) { return d.x; })
		        .attr("cy", function(d) { return d.y; });
		  });
		});
		$('#loading').hide();
		$('#chart').show();
	}
}
//End Function:	searchNetwork()



//Function:	pushToHub()
//Input Var(s):	none
//Description:	This function will push the gene currently selected by the user
//		to one of the "Hub Genes" list.
function pushToHub()
{
	//alert('pushToHub()');
	var list = $('#autoCom');
	var len = list.children().length;
	var crntSel = len;
	var tempSearch = "";
	list.children().each(function(index) {
		var sel = $(this).css('font-weight');
		if(sel != "normal" && sel != 400) {
			crntSel = index;
			tempSearch = $(this).attr('data-gene');
		}
	});
	putSearchTerm(tempSearch);
}
//End Function:	pushToHub()





//Function:	upAuto()
//Input Var(s):	none
//Description:	This function will select a gene directly above the currently
//		selected gene in the auto-complete menu.
function upAuto()
{
	//alert('upAuto()');
	$('#autoTerms').show();
	var list = $('#autoCom');
	var len = list.children().length;
	var crntSel = len;
	list.children().each(function(index) {
		var sel = $(this).css('font-weight');
		if(sel != "normal" && sel != 400) {
			crntSel = index;
			$(this).css('font-weight','normal');
		}
	});
	if(crntSel == 0){ var target = len-1; }else{ var target = crntSel-1; }
	list.children().each(function(index) {
		if(index == target){ $(this).css('font-weight', 'bold'); }
	});
}
//End Function:	upAuto()



//Function:	downAuto()
//Input Var(s):	none
//Description:	This function will select a gene directly below the currently
//		selected gene in the auto-complete menu.
function downAuto()
{
	//alert('downAuto()');
	$('#autoTerms').show();
	var list = $('#autoCom');
	var len = list.children().length;
	var crntSel = -1;
	list.children().each(function(index) {
		var sel = $(this).css('font-weight');
		if(sel != "normal" && sel != 400) {
			crntSel = index;
			$(this).css('font-weight','normal');
		}
	});
	if((len-1) == crntSel){ var target = 0; }else{ var target = crntSel+1; }
	list.children().each(function(index) {
		if(index == target){ $(this).css('font-weight', 'bold'); }
	});
}
//End Function:	downAuto()




//Function:	clickNode()
//Input Var(s):	crntNode(string)
//Description:	This is mostly a debugging function for the HTML5 portion of the graph
//		as the flash portion is more developed. Evnentually, this function
//		will act the same as the flash version of the function.
function clickNode(crntNode)
{
	//var out = print_r(crntNode, 3);
	//document.getElementById("output").innerHTML = out;
	document.getElementById("searchTerms").innerHTML = "Name: "+crntNode.name+", ";
	document.getElementById("searchTerms").innerHTML += "Number: "+crntNode.index;

}
//End Function: clickNode()

//Fucntion:	handle_click()
//Input Var(s):	event(mouse click event)
//Description:	This function occurs when a user clicks a flash node.
//		That node that represents a gene is pushed to the
//		"hub gene" list. The user can then "re-draw" the graph
//		to actually display that node's children. Eventually,
//		I would want to automatically add that node's children
//		to the graph without reloading the whole thing.
function handle_click(event){
	//alert('single click\n'+event);
	var target = event.target;
	var crnt_name = target.data.label;
	var searched = target.data.searched;
	//putSearchTerm(crnt_name);
	ajax_showTooltip(window.event,'/inc/ajax/getGene.php?title=' + crnt_name + '&searched=' + searched, this);
	//$("#results").text("");
	//$("#cytoscapeweb").text("");
	//var search = $("#searchTerms").text().toLowerCase();
	//$("#autoTerms").hide();
	//searchNetwork(search);
}
function randomColor(){
	var letters = '0123456789ABCDEF'.split('');
	var color = '#';
	for (var i = 0; i < 6; i++ ) {
		color += letters[Math.round(Math.random() * 15)];
	}
	return color;
}
function handle_dblclick(event){
	alert('double click\n'+event);
}
/**
  * Function : dump()
  * Arguments: The data - array,hash(associative array),object
  *    The level - OPTIONAL
  * Returns  : The textual representation of the array.
  * This function was inspired by the print_r function of PHP.
  * This will accept some data as the argument and return a
  * text that will be a more readable version of the
  * array/hash/object that is given.
  */
function dump(arr,level) {
	var dumped_text = "";
	if(!level) level = 0;
	
	//The padding given at the beginning of the line.
	var level_padding = "";
	for(var j=0;j<level+1;j++) level_padding += "    ";
	
	if(typeof(arr) == 'object') { //Array/Hashes/Objects
		for(var item in arr) {
			var value = arr[item];
			
			if(typeof(value) == 'object') { //If it is an array,
				dumped_text += level_padding + "'" + item + "' ...\n";
				dumped_text += dump(value,level+1);
			} else {
				dumped_text += level_padding + "'" + item + "' => \"" + value + "\"\n";
			}
		}
	} else { //Stings/Chars/Numbers etc.
		dumped_text = "===>"+arr+"<===("+typeof(arr)+")";
	}
	return dumped_text;
} 
